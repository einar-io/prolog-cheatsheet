Einar's Prolog Cheatsheet
=========================

##### Purpose
For use in PLD2020. This is only tested on SWI-Prolog.

Command-line interfaces, CLI for short, such as Prolog interpreters, is a powerful paradigm,
but as with everything in programming languages it is a trade-off.
This paradigm trades power and do-not-get-in-my-way for discoverability.
Thus is can be hard to see what you should know.

If you want to learn Prolog you need more than a cheatsheet, so head over to:
1. [Learn Prolog Now!](http://www.learnprolognow.org/)
2. [`comp.lang.prolog` FAQ](https://www.metalevel.at/prolog/faq/)


##### Fundamentals
Open your interpreter by `prolog` or `swipl`.

`halt.` or `Ctrl-D` to quit Prolog.

Queries, clauses and commands must end with `.`.
The number `n` of parameters a function takes is called its arity.
Functions that have the same name but different arity are considered distinct.
They are referred to with their name plus suffix of `/n`, such as
`halt/0`, `help/1`, `listing/0`, `listing/1`, `=/2`.
The latter being the infix unifier operator (MGU).
To _apply_ a function you write `listing(machine).`
To "run" a nullary function such as `halt/0`, you can write `halt.` instead of `halt().`

Functions are not technically functions, but you will figure this out as you get
absorbed in the Prolog approach.

Prolog are about knowledge in form of facts and _inferred_ knowledge from
composition of facts and _rules_. Unlike relational databases, Prolog program
text contains both the rows and the code. The queries are issued in the
interpreter.

Prolog uses the [closed world assumption(https://www.metalevel.at/prolog/faq/):
if something cannot be proven, it is considered false.


##### Help and documentation.

1. `help(F).` to learn about a function `F`. Press `q` to quit the pager.
    E.g. `help(help).`, `help(occurs).`, `help(append)`.

2. `apropos(appropos).`
    "Print objects from the manual whose name or summary match with query."

3. Remember Prolog program text is called "knowledge base", e.g. `myKnowledgBase.pl`.
   `[myKnowledgeBase]` loads said knowledge base.
   `['myKnowledgeBase']` loads said knowledge base but with `tab` completion.

4. `listing.` List current knowledge base.
   `listing(myPredicate)` List all rules for `myPredicate`.


##### (Unsearchable) syntax

5. `?-` Prompts you for a query. This happens in the interactive interpreter.
6. `:-` Is a rule constructor `<=`. This occurs only in the knowledge base files.

A variable _start_ with a capital letter or for special purposes `_`.
The special variable `_` is akin to the wildcard in ML like functional languages
and matches without introducing a binding.

Variables are _instantiated_ as Prolog search for solutions (satisfying assignments).


#####Rules

Modus Ponens: `p -> q /\ p => q`.
In maths you write `p -> q` or `body -> head`.
In Prolog you write `head :- body.` or `q :- p`.

You can read it as
"Head is true if Body is true"
Or: head _if_ body

#### Terms:
1. predicates are functions that return a boolean values
2. query
3. fact
4. predicate(args)    meaning predicate is true for args.
5. rule (head, body)
6. goals (in the body)
7. clause
8. jatom        lowercase, 'sad asd s'
9. variable start with A or _. Autogenerated variables are usual _...
10. complex term (constructor/functor()) <functor>(<term1>,<term2>,...,<term>)
11. Files are called Knowledge Bases
12. Points in the search where there are several alternative ways of unifying a goal against the knowledge base are called choice points. 
13. backtracking
14. choice point

###### Lists:
1. list: `[a,..,b]`
2. empty list: `[]`
3. head/tail: `[H|T]` head is an element, tail is a list.

###### Queries
You issue a query by putting a variable where you want to find a valid
assignment. E.g.

```
interpreter(T,arm).
```
Since `T` is a variable, Prolog will try to instantiate it to a value based on
the knowledge base _to make it `true`_. When there are no variables, Prolog will
return the truth value itself.

```
interpreter(plankalkul,kernekrigscomputer).
```

When more results you can press `space` to iterate over them or `;`, which is
read as `or` between solutions.

Constants: atoms or numbers

###### Set, bags and more
Sometimes you just want to see _all_ solution up front.

Find unique solutions:
`setof(X, canRun(M), _ ).`
List of unique solutions:
`setof(X, canRun(X), L).`
cf. `bagof`, `findall`



##### Unsearchable operator names
1. `,` conjunction (and) see `help(,/2)`
2. `;` disjunction (or)  `help(;/2)`
3. `\+` negation with a caveat."Not-provable operator" is more appropriate. `help(\+/2)`
4. `\!` cut -- stops backtracking at this goal. `help(\!/2)`
5. `=` unify `tree(leaf(1),leaf(2)) = tree(T,B)`
6. unify two terms with `=/2`  (equal with two args)
7. `einar = X` see `help(=/2)`
8. `einar \= X` same as `\+ Term1 = term2` see `help(\=/2)`




##### Debugger
1. `trace.` Trace the next query. Use this if you want to see how Prolog
   searches through the clauses.
2. `gtrace.`[visual tracer](https://www.swi-prolog.org/gtrace.html) trace next query in GUI.
3. `leash(+unify)`. "The special shorthand all refers to all ports, full refers to all ports except for the unify port (default)."

###### Usage:
- `h` for help.
- `space`/`c` step is called _creep_.
- `l`/ continue is called _leap_.
- `Ctrl-C`
- `spy`


#### Error Messages:
```
singleton: varilabels: U are not constraining the variable. Add constraints or Use _ to ignore the variable.
```
The rule you wrote does not depend on the variable in question. This is
sometimes due to a typo. If not you should change the variable to `_` to express
that intent.

```
Warning: /diku/pld-ta/git-repo/tombstone.pl:21:
	Clauses of program/1 are not together in the source-file
	  Earlier definition at /diku/pld-ta/git-repo/tombstone.pl:13
	  Current predicate: interpreter/2
	  Use :- discontiguous program/1. to suppress this message
```
A good practice is to "sort" your file on the clause level to avoid mistakes.


#### Advanced
###### Occurs check and setting flags.
SWI-Prolog does not perform the occurs check, so `MGU(A,a(A))` succeeds per default.

1. `?- unify_with_occurs_check(A,a(A)).`
   You can force the occurs check by this query (remember tab completion), e.g.
   `?- unify_with_occurs_check(a(A), A).` returns `false.`

2. `?- set_prolog_flag(occurs_check,true).`
   Or change the default behaviour. You can probably save this in `~/.swiplrc`

3. `?- current_prolog_flag(occurs_check,A).`
   This is the way you read a setting in Prolog, effectively unifying a variable
   with the setting.








#### Autorun Query on Load

When developing it is handy to run a certain query after loading your knowledge
base, e.g. after typing `['myKB.pl']`. You can do this by producing the set of
all solutions, effectively making them unique.
Notice that this is SWI-Prolog dependent syntax.


```
runnables(L) :- setof(_, canRun(L), _).

main :- forall(runnables(L), (write(L), nl)).

:- main.
```



#### Research needed:

1. Reset interpreter for knowledge.
